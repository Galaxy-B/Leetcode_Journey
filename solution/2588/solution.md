# Q2588：统计美丽子数组数目

异或（模 2 加法）运算的壹千零壹个巧妙性质 ^^

## 难度

+ Leetcode 分级：**中等**

+ Leetcode Rating：**1696**

## 标签

+ 哈希表

+ **位运算**

+ **前缀和**

## 解法

为了更直观地理解题目的操作要求，我们将测试用例中给出的 **美丽子数组** `[4,3,1,2,4]` 转换为二进制：

<center> 100 </center>
<center> 011 </center>
<center> 001 </center>
<center> 010 </center>
<center> 100 </center>

结合字面意思不难看出， **美丽子数组** 就是满足所有元素转换为二进制后，各位置均满足 **1** 共出现偶数次的子数组。相信熟悉位运算的观众们已经有所察觉，`nums[i,j]` 是 **美丽子数组** 恰恰等价于：

$$ xor(nums[i,j]) = nums[i] \oplus nums[i+1] \oplus ... \oplus nums[j] = 0  $$

换言之，我们需要统计的其实是 `nums` 中所有异或值为 **0** 的子数组。异或运算实质上是 **mod 2** 空间下的加法运算，这一性质允许我们应用前缀和的思路，来将朴素的 **平方** 级时间复杂度的算法优化为 **线性** 级的：

$$ a \oplus b = a \iff b = 0 $$

$$ xor(nums[0,i]) = xor(nums[0,j]) \iff xor(nums[i+1,j]) = 0 $$

基于上式，只需要在遍历 `nums` 的过程中维护一个 `<xor, count>` 的映射，就能在遍历到 `nums[i]` 时以 ***O(1)*** 的时间复杂度计算出以 `nums[i]` 结尾的，异或值为 **0** 的子数组数量，也即 **美丽子数组** 的数量。

## 复杂度

$$ 时间复杂度：O(n) $$

基于前缀和的思路，一趟扫描即可得到最终的答案。

$$ 空间复杂度：O(n) $$

引入哈希表带来的空间复杂度，最坏情况下 `nums[0,k]` 的异或值均互不相同，其中 `k∈[0,n)` 。