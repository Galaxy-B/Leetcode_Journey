# Q0003：无重复字符的最长子串

初识滑动窗口 ^^

## 难度

+ Leetcode 分级：**中等**

+ Leetcode Rating：**null**

## 标签

+ 哈希表

+ **滑动窗口**

## 解法

朴素地，我们可以遍历字符串的每个元素 `str[i]`，并探测以 `i` 起始的无重复字符子串 `str[i,j]` 的长度，所有结果中长度最大的子串便是最终的答案。但这种方法的复杂度是 **平方** 级别的（准确的说是 ***O(26n)*** :p），有没有什么办法可以一趟扫描就找出最长的无重复字符子串呢？

有的兄弟，有的。我们可以维护一个动态的窗口 `str[head,tail)`，并始终保持窗口内为一个无重复字符的子串。正因如此，窗口的尾指针 `tail` 可以不断向后滑动，直至新引入窗口的元素破坏了无重复字符的要求。这时窗口内便是一个 **局部的** 最长无重复字符子串，此时为继续向后探测其它无重复字符的最长子串，必须从窗口中逐出头指针 `head` 指向的元素。

通过如此不断地 **滑动** 窗口，我们总能发现 **局部的** 最长无重复字符子串，其中最长的那个便是我们想要的答案。

聪明的读者应该已经想到，我们需要一个类似 **集合** 的数据结构来帮助我们追踪当前窗口内保有的各种字符。哈希表或者 C++ 与 Python 中提供的 **(unordered)set** 都是合适的选择，但鉴于本题对字符范围的限定，使用数组搭配一个简单的映射便能得到性能更优的实现。

## 复杂度

$$ 时间复杂度：O(n) $$ 

头指针 `head` 与尾指针 `tail` 都只会扫描字符串一趟。

$$ 空间复杂度：O(1) $$ 

引入集合带来的空间复杂度，但任一时刻只会有至多26个字母被存储在集合中。